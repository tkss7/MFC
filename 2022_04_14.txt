메시지를 하나하나 읽어서 메시지 프로시저가 처리해줌 --> MFC는 이런걸 다 숨겨서 메시지 맵으로 다 표시함

핸들러 = 처리기 , 메시지핸들러 == 메시지 처리기

m_pMainWnd == 윈도우 핸들
AfxGetMainWnd() =AfxGetApp()->m_pMainWnd

(CFrameWnd*)AfxGetMainWnd())->GetActiveDocument() == 앱에서 DOC 호출하기

M : Model
V : View
C : Controll

MFC에서는 Doc/View구조가 1: N이다 Doc : 1 , View : N개

관찰자 패턴 = Doc/View 구조 일 대 다의 구조를 쓰는 모든건 이 패턴임

=====숙제 ====== 관찰자 패턴을 찾아봐라



Data = Doc
표현 출력  View

MFC에서는 문자열에 관해서는 CString m_strText; 이런식으로 쓴다.

OnPaint 함수는 WM_PAINT로 호출되는 메소드며 OnPaint 에서 OnDraw를 호출해서 우리는 OnDraw에서만 코딩하면 된다??

CView엔 WM_PAINT가 있고 이게  OnDraw를 호출한다.


함수내용 검색 = 한칸 뛰고 그 단어에 F1

m_bMouseDown 을 트루펄스로 해놓으면 다운이 내 뷰에서만 동작할수도 있다? == 시작 , 이동 , 종료를 하나의스텝으로 봄
==마우스를 띨 때 까지 제어권을 내가 갖고 있어야 해

(nFlags & MK_LBUTTON) == MK_LBUTTON : 시작점을 다른애로 설정 가능 == 다른 윈도우에서 메시지가 와도 동작가능
== 내가 만든 프로그램 밖의 프로그램으로 이벤트가 넘어 갈 수 있음

SetCapture(); == 해당 윈도우를 벗어나도 제어권을 항상 내가 갖고 있다
// 디폴트는 윈도우를 벗어나면 밖의 윈도우에 제어권이 넘어간다

ReleaseCapture(); == ??


생성한 펜을 DC의 현재 펜으로 변경하고 기존 펜 객체에 대한 포인터를 별도로 저장해둔다.

======================즉==============================================================
bool m_bMouseDown 로 직접 플래그를 선언 후 사용시 시작점이 내 윈도우의 View영역 안에서만 가능하며

(nFlags & MK_LBUTTON) == MK_LBUTTON 로 if문을 돌릴 시 시작점이 내 윈도우의 View가 아닌 프레임영역이라도 시작점으로
사용이 가능하다.

다만 두 경우 모두, 클릭 후 마우스가 내 윈도우 영역을 벗어나 바탕화면쪽으로 가면 제어권이 바탕화면쪽 시스템으로 넘어가는데

마우스의 제어권을 항상 내가 갖고 싶다면  마우스 좌클릭 다운에 SetCapture(); , 마우스 좌클릭 업에 ReleaseCapture(); 를
사용하면 된다.
======================================================================================


DC : 디바이스에 대한 정보 : 논리
장치에 대한 정보를 갖고있다.
GetDC : 객체
ReleaseDC : 다쓰고 객체 버림
DC = 스케치북
GDI = 연필(함수)
WM_PAINT메시지로 그리면 중첩된다?

ClientDC = 임시로 그리고 끝
CPaintDC = 계속 남겨놓음

가려졌다 나타나면 그 영역이 무효화영역이 되고 그 영역만큼 리드로우를 해준다.

CPaintDC는 OnPaint , WM_PAINT 메시지에서만 쓴다
나머지 일반함수에서는 CClientDC를 쓴다 == 순간적으로 출력이되고 사라질 수 있다.

따라서 뷰에다 그릴꺼면 무조건 OnDraw에 그려라

윈도우는 특별한 순간만 저장하고 나머진 무조건 그냥 그린다
==> 리사이즈 할 때마다 WM_Paint에서 다시 그린다

윈도우가 자기 영역에 출력한 정보를 저장하는 메모리는 없다
다만 출력을 좋게 하기위해 순간적으로 메모리를 쓰고 버리는 경우는 있다.

인벨리데이트하면 계속 깜빡깜빡 거리기 때문에 그 때만 그림을 그리면 된다?( 임시로 그림을 그리면 된다.) == CClientDc를 이용해
그림을 그린다!!!!!!

IDM == 메뉴라고 알리는것이다.

도큐먼트 데이터를 처리해야하므로 메뉴에서 색상 바꾸기는 도큐먼트에서 하는게 제일 좋다.




마우스 다운 시 이전 데이터가 다 지워지고 클릭한 지점의 좌표가 벡터에 넘어감 ->
마우스 다운 상태로 움직이면 매번 벡터의 마지막 값을 시작점으로 삼아 움직여진 좌표값까지 선 그리고 움직여진 좌표값이
벡터의 다음 데이터로 들어감 : 이걸 계속 반복
마우스 업 시 만들어 놓은 윈도우 외부에 그려놓은거 까지 유지하고 릴리즈함 ( 말이 이상하니깐 몰라도 됨)
그 후 리사이즈하면 WM_PAINT 함수가 발생하여 OnDraw() 함수가 발생함 ->
직선으로 10포인트 굵기로 벡터에 저장되어 있는 좌표값들을 모두 그린다.
-> 다시 마우스 다운하면 이전데이터 지워지고 위의 루프 반복됨!!!!


마우스 다운에 인벨리데이트 선언 하면 첫 점찍은 부분이 OnDraw()에 있는 10포인트짜리로 찍히고 
드래그 시는 점선으로 그려져서 약간 콩나물 처럼 그려짐
마우스다운에서 인벨리데이트 선언 안하면 온드로우가 발생 안하므로 첫 점찍은 곳이 콩나물처럼 안생기며
온 마우스 무브에도 인벨리데이트가 없으므로 잔상처럼 계속 남다가 윈도우 창 리사이즈시 그제서야 온드로우가
호출되어 굵게 그려진다. 다만
마우스 다운에서 매번 데이터를 클리어 하므로 최종적으로 점선으로 그린것만 굵게 OnDraw되어 남아있다.

만약 온 마우스 무브에 인벨리데이트 선언 함녀 계속해서 그려지므로 메모리 많이먹게끔 많이 그리다보면 
화면이 깜빡깜빡하는게 눈에 보인다.


