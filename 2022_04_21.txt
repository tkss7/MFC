
통지메시지는 NMHDR을 무조건 첫번째로 갖고 우리는 형변환을 통해 이것을 사용해야한다.

통지메시지 = ON_NOTIFY(추가메시지, ID(윈도우 객체),
BN_CLIKED = 예전 버전 통지메시지
노티파이메시지헤더 = 핸들, ID, 코드
부모윈도우에서 자식윈도우를 관리할 때 고유한 번호(시스템이 정의한 )(hwnd)과 사용자가 정의한(ID)와 코드( code)로 관리한다.

Hdr       . hwnd
	. id
	. code

모든 주소 = 보이드 포인터

 핸들, ID, 코드 == 윈도우의 필수 정보
통지메시지마다 뒷단은 다르지만 핸들, ID, 코드는 필수적으로 가지고 있어야하므로 무조건 앞엔 NMHDR( Hdr)을 갖는다. 이후 멤버는 메시지마다 추가 정보가 다르니깐
변수들이 다르다.

자식이 부모에게 자신의 상태를 넘길때 구조체로 넘긴다.

reinterpret_cast = 강제적 형변환

논리적으로 해석하는 방향에 따라서 정수가 주소가 될 수도 있고 값이 될수도 있다.
10 = 10번쨰 메모리 위치를 의미한다. 다만 물리적으로 접근할수 없을 뿐
보이드 포인터 = 프리하다 = 어떤상황이든지 형변환 하여 자료구조를 만들어 써먹을수 있다 = 일반화

B* pObjB = dynamic_cast<B*>(p); == B로 형변환 가능한지 확인 후 불가능하면 ptrnull값을 반환함

reinterpret_cast<B*>(p) = 형변환 가능한지 관심없고 무조건 재해석해서 강제로 형변환 시켜버린다.
다른타입이더라도 논리적으로 해당되는 타입으로 보겠다.
// 내부구조가 다르면 죽을수도 있다.
OLE2, COM 을 만들 때 썼다. = 지금은 거의 안씀



//cpp 클래스 -> 멤버변수
//객체화 될 때 멤버 변수 확보가 됨
//HWND : 윈도우 핸들 CreateWindow()가 호출이 되면 만들어짐 (API)
//CWnd : HWND을 가지고 Window API를 호출 할 수 있다.

//dlg.DoModal() : 이걸 호출하면 자동적으로 대화상자를 만든다

GetSafeHwnd() :  // 윈도우가 정상적으로 생성이 되었는지 여부를 판단하는 함수 // 생성안되면 NULL, 생성되면 NULL이 아님
DoModal에서는 윈도우가 생성이 되어도 제어권이 다시 부모한테 갈 수 있다. == 이전 창을 클릭 가능
모달리스는 닫아도 객체가 제거되는게 아니라 숨는 것이다 
모달은 객체가 닫으면 아예 파괴되고 열면 다시 만든다.

포커스 벗어나는것도 이벤트로 있다.

특별함 = 데이터처리 및 UI출력이 한곳에서 다 이루어지는 것 = 좋은방법이 아니다.

데이터 처리 = Document

데이터 출력 = View , Dialog


virtual 쓰면 __vfptr 이라는 가상함수 테이블이 만들어짐 == 이것도 일종의 변수다 == 메모리를 가짐

CMember 객체의 데이터를 CMemberManagement 클래스에서  리스트, 벡터, 맵 등의 형태로 담고 있는게 좋다

CMemberManagement 에 등록, 호출, 삭제 메소드를 담아야한다

m_strID.GetLength()==0 or m_strID.Isempty()==0


모달 ok 눌리면 Document에 있는 Memberptr에 저장??
랩핑 = 감싸는것

중복처리 과제 래 

화면전환 ctrl + Tab

선언할 때 보니깐 Doc.h에 데이터들 클래스로 만들고 그것 관리하는 핸들러 클래스 만들고
데이터 클래스의 포인터형 을 재정의? 비슷하게 해서 하나 만들고
다이얼로그는 데이터클래스와 1:1 통신?을 해야하니깐 데이터 클래스 포인터형을 통해 삭제 얻기, 설정 등의 
함수를 만들며, 뷰에서는 그냥 Dlg랑 Doc안의 객체들 선언 및 접근해 가면서 데이터 사용? 하는듯 함