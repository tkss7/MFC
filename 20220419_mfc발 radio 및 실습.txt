radio =====================================================================

radio : 그룹에 대해서만 값을 주고 각각의 레디오에 대해서만 컨트롤로 설정가능
  ①하나만 선택가능
  ②생성하기 위한 조건
     - 그룹속성 선택 : 그룹속성에서 시작점을 false가 아닌 ture 설정
     - 탭오더 설정 : 탭오더를 그룹속성의 시작점부터해서 설정을 해줘야함


=====================================================================
매서드 생성시
	1. UI에 입력된 값을 변수로 읽는다.
	2. 입력된 값을 이용하여 Member 객체를 생성한다
	3. 어디가 저장될 공간(1. vector, 2. map, 3.db) 에 저장한다
	4. vector에 저장을 한다고 생각하고 어떤 객체를 저장할지?
	5. 저장 방법 : 
		① 객체 vector<CMember>
		②포인터 (동적객체) vector<CMember*>, 소멸자에서 객체 해제 반드시 할 것 
		③스마트 포인터 vector<CMemberPtr>
==================================================================
스마트포인터 - 포인터처럼 동작하는 클래스 템플릿으로, 사용이 끝난 메모리를 자동으로 해제

■종류
	1.unique_ptr : unique_ptr은 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록, 객체에 소유권 개념을 도입
	2.shared_ptr : 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지를 참조
	3.weak_ptr : 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만, 소유자의 수에는 포함되지 않음


나머지 스마트 포인터는 알아서 찾을것
=============================================================
람다구문 : 클래스 선언하고 비슷하다, 람다는 선언이 빠지고 바로 구현이 가능하다

구문 : [캡쳐](인자부분) -> {실행부분};

         ex)①[캡쳐](인자부분) -> {return ???};
	②  auto func = [캡쳐](인자부분) -> {return ???};
	③auto add_func = [](int a, int b) ->int {return a+b;};
	 실행 : result = add_function(10,20)

캡쳐구문 
- 람다구문을 일종의 객체라고 생각해라
- 루프안에서 보존되는 초기데이터

=================================================================
find_if

cppreference
