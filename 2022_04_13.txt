App = exe
doc = 데이터 관리
frame = 창
view = 안쪽 영역

콜백 : 시스템이 내가 만든 함수를 호출해준다 == C++의 virtual 함수

콘솔의 main()은 함수가 끝나기 전까지 시스템에 제어권이 안넘어감

MFC는 내가 처리해야할 상황이 될때만 나를 시스템이 호출해서 처리한다.(잠깐만 제어권 나한테 넘김)
ex) WndProc이라는 함수를 이용해서 뭔가를 처리한다.
DefWindowProc  == 윈도우한테 내가 처리할 것이 없으니 다시 제어권을 넘긴다
return 0 = 내가 처리한다.

윈도우는 메시지를 중심으로 동작한다
메시지 큐에서 메시지를 가져오는데 큐에 메시지가 없으면 시스템이 제어권?

메시지 큐에서 메시지를 읽어(DispatchMsg)
hWind

WndProc -> 레지스터에 전달?
메시지를 받아서 DispatchMsg를 통해 메시지를 처리?

응답없음 : 프로그램이 제어권을 시스템에게 반환을 안 한 경우? == WindowProc()에서 빨리 처리하고 제어권을 시스템에게 넘겨줘야하는데
안주고 계속 무한루프마냥 갖고있으면 발생함

윈도우 창의 작은 하나하나가 윈도우고 윈도우 핸들이 이것들을 번호로 매겨 갖고있다??
씨발


CCmdTarget

CWnd : wind32 API가 여기에 재정의 되어있다고 생각 ㄱㄱ

m_pMainWnd == CWnd 의 객체임

내 메시지가 아닌 내가 처리할 메시지가 아닌것도 온다 메시지큐에

API를 직접처리하는게 아니라 쓰레기인지 아닌지 확인하는 코드로 감싸여 있다.

윈도우 핸들이 의미가 있어야 한다 -> 만들어야 하는 시점 : 바깥에 있는 부모 윈도우가 만들어 진 시점 = WM_CREATE 를 받은 시점


Afx가 앞에 붙은 것 = 전역함수

AfxGetApp()을 호출하면 CWinApp의 포인터가 리턴이 된다.


CWinApp -> CDocument -> CFrameWnd -> CView

처리루틴 : 핸들러

클래스뷰 -> 이벤트 

여러문서냐 단일문서냐에 따라 뭔가 다르다
--> 여러문서면 메인프레임과 자식 프레임들로 나뉨

핸들 : 내부적으로 관리하기 위한 번호를 부여하는 것이다.

4장은 잠이 안올 때 봐라

메모리할당 해제할꺼면 디스트로이에서 해라

키 다운 : 키가 눌리자마자 동작
키 업 : 키가 눌리고 다시 튀어나올 때 동작

모니터중심으로 보는 좌표 : 절대좌표

NoZORDER : 상하좌우는 안해?? ㅁㄹ


/c++ ---> 프로젝트 속성 ----> 미리 컴파일된 헤더 ---> 미리 컴파일된 헤더에서 "사용"
---> 미리 컴파일된 헤더파일에 pch.h 작성

pch.cpp 에서 위와 같은 과정에서 미리 컴파일된 헤더에서 "만들기" 로 적용