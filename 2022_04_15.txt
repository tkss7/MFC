처음부터 설계하는건 어렵다 -> 하나하고 점차점차 늘려나간다
TDD : 

델리트 컨텐츠부터
각 메소드는 하나의 기능만 하도록 작성하는게 좋다

x64 x86은 m_line 사이즈가 각각 8 4 바이트이므로
데이터를 받아올때 line_size가 다르므로 타입(사이즈)를 맞춰야 한다.

펜은 포인트로 x,y를 설정함
구조체로 Write, Read 하는 이유 : IO의 횟수를 줄일 목적으로 쓴다.
디바이스에선 한번 한번이 은근 중요해서 가능하면 성능적인 면에서 블록형태로 한번에 읽고 쓰는게 좋다.

resize()로 공간 만들어 놓고 한번에 입출력??? 씨발 뭐라는거야

프로그램은 항상 버그가 있을 수 있다.

다른 이미지 저장해서 사용하고 싶으면 파일형식을 256 비트맵으로 하면 된다.
점 하나가 4비트 ==  24비트 비트맵 == true칼라

옛날 윈도우버전은 24비트 비트맵을 쓰면 깨져서 브러쉬로 쓰지 않았다.

삼각형 그리기 예제 파일 경로:
D:\MFC2\도서자료_Visual+C+++2008+MFC+윈도우프로그래밍(예제파일)_20180420\열혈강의 Visual C++ 윈도우 프로그래밍 - 예제 소스코드\Part 1 윈도우 프로그래밍의 기본\07장 GDI 기본\TriangleDemo


memset() //메모리를 셋팅하는 함수

디버깅창 ->자동 -> 변수 펼쳐보면 값들 확인 가능 :: 확인 하고픈 줄에 커서두고 F10

// 메모리 DC에 들어 있는 비트맵을 화면 DC로 복사하여 출력한다.
dc.BitBlt(0, 0, bmpInfo.bmWidth, bmpInfo.bmHeight,


CDC MemDC; //장치에 관련된 자료구조
MemDC.CreateCompatibleDC(&dc); //화면에 출력하기 위한 메모리에 로딩하기위한 과정

CBitmap bmp; // 비트맵에 관련된 정보를 갖고 있음(4/8/16/32)
CBitmap* pOldBmp = NULL;
bmp.LoadBitmap(IDB_Test_Image);
bmp.GetBitmap(&bmpInfo); // 로딩된 비트맵의 정보를 알아본다. 이미지의 폭과 높이



과제---- 비트맵 이미지 마우스로 확대 축소 가능하게끔



9장 X
10장 11장 한다.  오늘은 10장까지만
다음주 11, 12, 13, 14, 15:리스트컨트롤 대화상자, 17, 18장 : 깜빡임, 19 , 23, 29장: 멀티스레드 개념만, 32장 : DLL , 
36장 : DB== 다다음주 에 진행(2주)
DB : 로컬

WM_COMMAND = x86 =  4바이트 , 앞 2바이트 = 이벤트, 뒤 2바이트 = ID값
WM_XX :: 윈도우한테만 간다. 


도큐먼트, 윈앱 = 윈도우가 아니다,
윈도우 메시지는 뷰 프레임만 가능
WM_COMMAD = 앱, 도큐먼트만 가능하다?

업데이트커멘드 유아이 = 체크박스 등에 씀, 메뉴, 상태바 글자 바꾸기 등...

메뉴추가 = insert 키


처리순서 = 프레임 -> 다큐먼트 -> 뷰 -> 앱

윈도우 메시지는 한군데서만 처리
메뉴는 4군데에서 처리 가능하지만 여러곳에서 같은 이벤트를 작성 할 경우 4군데에서 한곳만 동작한다. 처리순서는 프레임 -> 다큐먼트 -> 뷰 -> 앱 순서

메뉴바 - 속성 - 프롬프트 가 밑에 상태 표시줄(도구 바)에 나올 글자를 말한다.







